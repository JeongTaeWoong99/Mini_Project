// ============================================================================
// URP ê¸°ë³¸ ì…°ì´ë” - World Positionì„ ìƒ‰ìƒìœ¼ë¡œ í‘œí˜„
// ============================================================================
//
// ğŸ“– í•™ìŠµ ë‚´ìš© (PDF 42p) :
// - ë³´ê°„ê¸°(Interpolator)ë¥¼ ì •ì˜í•˜ê³  World Position ê°’ì„ ì˜¤ë¸Œì íŠ¸ ì»¬ëŸ¬ë¡œ í‘œí˜„
// - TransformObjectToWorld()ë¡œ ë¡œì»¬ â†’ ì›”ë“œ ì¢Œí‘œ ë³€í™˜
// - sin(_Time.y)ë¥¼ í™œìš©í•œ ë²„í…ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ì‘ìš©
//
// ============================================================================

Shader "URPTraining/URPBasic_8"
{
    // [Properties] : Material Inspectorì— ë…¸ì¶œí•  ë³€ìˆ˜ë“¤
    Properties
    {
        _TintColor("Tint Color" , Color)       = (1, 1, 1, 1) // í‹´íŠ¸ ìƒ‰ìƒ (RGBA)
        _Intensity("Intensity"  , Range(0, 1)) = 1               // ê°•ë„ ìŠ¬ë¼ì´ë” (0~1)
    }

    SubShader
    {
        Tags
        {
            "RenderPipeline" = "UniversalPipeline"
            "RenderType"     = "Opaque"
            "Queue"          = "Geometry"
        }

        Pass
        {
            Name "Universal Forward"
            Tags { "LightMode" = "UniversalForward" }

            HLSLPROGRAM

            #pragma target   3.5
            #pragma vertex   vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // [CBUFFER] : SRP Batcher ì§€ì›
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            CBUFFER_START(UnityPerMaterial)
                half4 _TintColor;
                float _Intensity;
            CBUFFER_END

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // [VertexInput] : GPUê°€ ë©”ì‹œì—ì„œ ì½ì–´ì˜¬ ë°ì´í„°
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            struct VertexInput
            {
                float4 vertex : POSITION;   // ë²„í…ìŠ¤ ìœ„ì¹˜ (ë¡œì»¬ ì¢Œí‘œ)
            };

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // [VertexOutput] : ë²„í…ìŠ¤ â†’ í”½ì…€ ì…°ì´ë”ë¡œ ì „ë‹¬í•  ë°ì´í„° (ë³´ê°„ê¸°)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            struct VertexOutput
            {
                float4 vertex : SV_POSITION; // í™”ë©´ìƒ ìœ„ì¹˜ (í´ë¦½ ì¢Œí‘œ)
                float3 color  : COLOR;       // ì›”ë“œ ì¢Œí‘œë¥¼ ìƒ‰ìƒìœ¼ë¡œ ì „ë‹¬
            };

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // [ë²„í…ìŠ¤ ì…°ì´ë”] : ì›”ë“œ ì¢Œí‘œë¥¼ ìƒ‰ìƒìœ¼ë¡œ ì „ë‹¬
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            VertexOutput vert(VertexInput v)
            {
                VertexOutput o;

                // ë¡œì»¬ ì¢Œí‘œ â†’ í´ë¦½ ì¢Œí‘œ ë³€í™˜
                o.vertex = TransformObjectToHClip(v.vertex.xyz);

                // ë¡œì»¬ ì¢Œí‘œ â†’ ì›”ë“œ ì¢Œí‘œ ë³€í™˜ í›„ ìƒ‰ìƒìœ¼ë¡œ ì €ì¥
                o.color = TransformObjectToWorld(v.vertex.xyz);

                return o;
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // [í”½ì…€ ì…°ì´ë”] : ì›”ë“œ ì¢Œí‘œ ê¸°ë°˜ ìƒ‰ìƒ ì¶œë ¥
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            half4 frag(VertexOutput i) : SV_Target
            {
                float4 color = float4(1, 1, 1, 1);

                // ì›”ë“œ ì¢Œí‘œ(color)ë¥¼ RGBë¡œ ì‚¬ìš©
                color.rgb *= _TintColor.rgb * _Intensity * i.color;

                return color;
            }

            ENDHLSL
        }
    }
}