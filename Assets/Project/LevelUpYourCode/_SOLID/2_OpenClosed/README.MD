# ğŸ”“ Open-Closed Principle (ê°œë°©-íì‡„ ì›ì¹™)

## ğŸ“‹ ëª©ì°¨
- [ì›ì¹™ ê°œìš”](#-ì›ì¹™-ê°œìš”)
- [ì™œ OCPê°€ í•„ìš”í•œê°€?](#-ì™œ-ocpê°€-í•„ìš”í•œê°€)
- [í•µì‹¬ ê°œë…](#-í•µì‹¬-ê°œë…)
- [ì½”ë“œ êµ¬ì¡°](#-ì½”ë“œ-êµ¬ì¡°)
- [Before & After ë¹„êµ](#-before--after-ë¹„êµ)
- [ì‹¤ì „ ì‹œë®¬ë ˆì´ì…˜](#-ì‹¤ì „-ì‹œë®¬ë ˆì´ì…˜)
- [ì£¼ìš” ì½”ë“œ ë¶„ì„](#-ì£¼ìš”-ì½”ë“œ-ë¶„ì„)
- [ì¥ë‹¨ì ](#-ì¥ë‹¨ì )
- [ì‹¤ì œ ì ìš© ì‚¬ë¡€](#-ì‹¤ì œ-ì ìš©-ì‚¬ë¡€)
- [í•™ìŠµ ì •ë¦¬](#-í•™ìŠµ-ì •ë¦¬)

---

## ğŸ¯ ì›ì¹™ ê°œìš”

**Open-Closed Principle (OCP)** ì€ **SOLID ì›ì¹™**ì˜ ë‘ ë²ˆì§¸ ì›ì¹™ìœ¼ë¡œ, ì†Œí”„íŠ¸ì›¨ì–´ ê°œì²´ëŠ” **í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼** í•œë‹¤ëŠ” ì›ì¹™ì…ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ ê°œë…

```
í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³  (Open for Extension)
ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤ (Closed for Modification)
```

**í™•ì¥ì— ì—´ë ¤ ìˆë‹¤ (Open for Extension) :**
- âœ… ìƒˆë¡œìš´ ê¸°ëŠ¥(ë„í˜•)ì„ **ììœ ë¡­ê²Œ ì¶”ê°€**í•  ìˆ˜ ìˆë‹¤
- âœ… **ìƒˆ íŒŒì¼**ì„ ë§Œë“¤ì–´ì„œ í™•ì¥í•œë‹¤

**ìˆ˜ì •ì— ë‹«í˜€ ìˆë‹¤ (Closed for Modification) :**
- âœ… ê¸°ì¡´ ì½”ë“œë¥¼ **ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ë‹¤**
- âœ… **ë²„ê·¸ ìœ„í—˜**ì„ ìµœì†Œí™”í•œë‹¤

---

## ğŸ¤” ì™œ OCPê°€ í•„ìš”í•œê°€?

### ë¬¸ì œ ìƒí™©

ê²Œì„ì—ì„œ ë‹¤ì–‘í•œ ë„í˜• íš¨ê³¼ì˜ ë©´ì ì„ ê³„ì‚°í•´ì•¼ í•˜ëŠ” ê²½ìš° :

```csharp
public class UnrefactoredAreaCalculator
{
    public float GetRectangleArea(Rectangle rectangle)
    {
        return rectangle.Width * rectangle.Height;
    }

    public float GetCircleArea(Circle circle)
    {
        return circle.Radius * circle.Radius * Mathf.PI;
    }

    // âš ï¸ ìƒˆ ë„í˜• ì¶”ê°€í•˜ë ¤ë©´?
    // â†’ ì´ í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•¨!
    // â†’ ê¸°ì¡´ì— ì˜ ì‘ë™í•˜ë˜ ì½”ë“œë¥¼ ê±´ë“œë ¤ì•¼ í•¨!
}
```

**ì´ ì½”ë“œì˜ ë¬¸ì œì  :**

âŒ **ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • í•„ìš”**
   - ìƒˆ ë„í˜• ì¶”ê°€í•  ë•Œë§ˆë‹¤ `UnrefactoredAreaCalculator` ìˆ˜ì •
   - ì˜ ì‘ë™í•˜ë˜ ì½”ë“œë¥¼ ê±´ë“œë ¤ì•¼ í•¨ â†’ ë²„ê·¸ ìœ„í—˜!

âŒ **í™•ì¥ì´ ì–´ë ¤ì›€**
   - ë©”ì„œë“œë¥¼ ê³„ì† ì¶”ê°€í•´ì•¼ í•¨
   - íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ì´ ê³„ì† ëŠ˜ì–´ë‚¨

âŒ **í…ŒìŠ¤íŠ¸ ë¶€ë‹´ ì¦ê°€**
   - í´ë˜ìŠ¤ ìˆ˜ì •í•  ë•Œë§ˆë‹¤ ëª¨ë“  ë„í˜•ì„ ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•´ì•¼ í•¨

âŒ **ì½”ë“œ ë³µì¡ë„ ì¦ê°€**
   - ë„í˜•ì´ ëŠ˜ì–´ë‚ ìˆ˜ë¡ í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§
   - ìœ ì§€ë³´ìˆ˜ê°€ ì ì  ì–´ë ¤ì›Œì§

### OCPì˜ í•´ê²°ì±…

âœ… **í™•ì¥ ê°€ëŠ¥**
   - ìƒˆë¡œìš´ ë„í˜•ì„ ììœ ë¡­ê²Œ ì¶”ê°€ ê°€ëŠ¥

âœ… **ê¸°ì¡´ ì½”ë“œ ë³´í˜¸**
   - ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ
   - ë²„ê·¸ ë°œìƒ ìœ„í—˜ ìµœì†Œí™”

âœ… **ë…ë¦½ì  í…ŒìŠ¤íŠ¸**
   - ìƒˆ ë„í˜•ë§Œ í…ŒìŠ¤íŠ¸í•˜ë©´ ë¨
   - ê¸°ì¡´ ë„í˜•ë“¤ì€ ì˜í–¥ë°›ì§€ ì•ŠìŒ

âœ… **ì„ í˜•ì  ë³µì¡ë„**
   - ë„í˜•ì´ ëŠ˜ì–´ë‚˜ë„ ë³µì¡ë„ê°€ ì„ í˜•ì ìœ¼ë¡œë§Œ ì¦ê°€

---

## ğŸ—ï¸ í•µì‹¬ ê°œë…

OCPë¥¼ ì´í•´í•˜ê¸° ìœ„í•œ í•µì‹¬ êµ¬ì¡° :

### ğŸ“ ì¶”ìƒí™”ì™€ ë‹¤í˜•ì„±

**í•µì‹¬ ì•„ì´ë””ì–´ :**
```
1. ì¶”ìƒ í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤ë¡œ ê³µí†µ ë™ì‘ ì •ì˜
2. êµ¬ì²´ í´ë˜ìŠ¤ë“¤ì´ ì´ë¥¼ ìƒì†/êµ¬í˜„
3. ìƒˆ ê¸°ëŠ¥ì€ ìƒˆ êµ¬ì²´ í´ë˜ìŠ¤ë¡œ ì¶”ê°€
4. ê¸°ì¡´ ì½”ë“œëŠ” ì¶”ìƒí™”ì—ë§Œ ì˜ì¡´ â†’ ìˆ˜ì • ë¶ˆí•„ìš”!
```

**êµ¬ì¡° :**
```csharp
// 1ë‹¨ê³„ : ì¶”ìƒí™” ì •ì˜
public abstract class AreaOfEffect
{
    public abstract float CalculateArea();  // ê³µí†µ ë™ì‘
    public void PlayEffect() { /* ... */ }  // ê³µí†µ ê¸°ëŠ¥
}

// 2ë‹¨ê³„ : êµ¬ì²´ í´ë˜ìŠ¤ êµ¬í˜„
public class CircleEffect : AreaOfEffect
{
    public override float CalculateArea()
    {
        return Radius * Radius * Mathf.PI;
    }
}

public class RectangleEffect : AreaOfEffect
{
    public override float CalculateArea()
    {
        return Width * Height;
    }
}

// 3ë‹¨ê³„ : ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ (ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ìŒ!)
public class HexagonEffect : AreaOfEffect
{
    public override float CalculateArea()
    {
        return (3 * Mathf.Sqrt(3) / 2) * SideLength * SideLength;
    }
}

// 4ë‹¨ê³„ : ì‚¬ìš©í•˜ëŠ” ìª½ (ìˆ˜ì • ë¶ˆí•„ìš”!)
public class EffectTrigger
{
    [SerializeField] AreaOfEffect m_Effect;  // ì¶”ìƒí™”ì—ë§Œ ì˜ì¡´

    void OnTriggerEnter(Collider other)
    {
        m_Effect.PlayEffect();  // âœ… ì–´ë–¤ ë„í˜•ì´ë“  ì‘ë™!
        // â†³ PlayEffect() ë‚´ë¶€ì—ì„œ CalculateArea() í˜¸ì¶œë¨
        //   â†’ CircleEffectë©´ â†’ CircleEffect.CalculateArea()
        //   â†’ HexagonEffectë©´ â†’ HexagonEffect.CalculateArea()
    }
}
```

---

## ğŸ“Š ì½”ë“œ êµ¬ì¡°

### í´ë” êµ¬ì¡°

```
2_OpenClosed/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ AreaOfEffect.cs              â† âœ… ì¶”ìƒ í´ë˜ìŠ¤ (ê³µí†µ ê¸°ëŠ¥)
â”‚   â”œâ”€â”€ CircleEffect.cs              â† ì›í˜• íš¨ê³¼
â”‚   â”œâ”€â”€ RectangleEffect.cs           â† ì‚¬ê°í˜• íš¨ê³¼
â”‚   â”œâ”€â”€ HexagonalEffect.cs           â† ìœ¡ê°í˜• íš¨ê³¼
â”‚   â”œâ”€â”€ TriangularEffect.cs          â† ì‚¼ê°í˜• íš¨ê³¼
â”‚   â”œâ”€â”€ EffectTrigger.cs             â† íš¨ê³¼ íŠ¸ë¦¬ê±° (ì‚¬ìš©í•˜ëŠ” ìª½)
â”‚   â”‚
â”‚   â””â”€â”€ Unrefactored/
â”‚       â””â”€â”€ UnrefactoredAreaCalculator.cs  â† âŒ OCP ë¯¸ì ìš©
â”‚
â””â”€â”€ README.MD                         â† ğŸ“ í˜„ì¬ ë¬¸ì„œ
```

### í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨

```
                    AreaOfEffect (ì¶”ìƒ í´ë˜ìŠ¤)
                           |
              +CalculateArea() (ì¶”ìƒ ë©”ì„œë“œ)
              +PlayEffect()
              +íŒŒí‹°í´/ì˜¤ë””ì˜¤ ê´€ë ¨ ê¸°ëŠ¥
                           |
         +-----------------+-----------------+-----------------+
         |                 |                 |                 |
    CircleEffect    RectangleEffect   HexagonalEffect   TriangularEffect
  +CalculateArea()  +CalculateArea()  +CalculateArea()  +CalculateArea()
  (ë°˜ì§€ë¦„ ê³µì‹)     (ê°€ë¡œÃ—ì„¸ë¡œ)       (ìœ¡ê°í˜• ê³µì‹)     (ì‚¼ê°í˜• ê³µì‹)


         EffectTrigger
              |
    AreaOfEffect ì°¸ì¡°  â† âœ… ì¶”ìƒí™”ì—ë§Œ ì˜ì¡´!
    - PlayEffect() í˜¸ì¶œ


VS (OCP ë¯¸ì ìš©)


    UnrefactoredAreaCalculator
              |
    +GetRectangleArea(Rectangle)  â† âŒ êµ¬ì²´ íƒ€ì…ì— ì˜ì¡´!
    +GetCircleArea(Circle)        â† âŒ ë„í˜• ì¶”ê°€ ì‹œ ìˆ˜ì • í•„ìš”!
    +GetTriangleArea(Triangle)    â† âŒ ë©”ì„œë“œ ê³„ì† ì¶”ê°€...
    +GetPentagonArea(Pentagon)    â† âŒ í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§...
    // ... ê³„ì† ì¶”ê°€
```

---

## ğŸ”„ Before & After ë¹„êµ

### âŒ Before : OCP ë¯¸ì ìš© (UnrefactoredAreaCalculator.cs)

```csharp
public class UnrefactoredAreaCalculator
{
    // Non-SOLID êµ¬í˜„ : ê°œë°©-íì‡„ ì›ì¹™ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    // ì´ ì ‘ê·¼ ë°©ì‹ì€ ì ì€ ìˆ˜ì˜ íš¨ê³¼ì—ì„œëŠ” ì˜ ì‘ë™í•˜ì§€ë§Œ,
    // í”„ë¡œì íŠ¸ê°€ ì»¤ì§€ë©´ í™•ì¥ì„±ì´ ë–¨ì–´ì§€ê³  ë‹¤ë£¨ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤.

    public float GetRectangleArea(Rectangle rectangle)
    {
        return rectangle.Width * rectangle.Height;
    }

    public float GetCircleArea(Circle circle)
    {
        return circle.Radius * circle.Radius * Mathf.PI;
    }

    // âš ï¸ ì‚¼ê°í˜• ì¶”ê°€í•˜ë ¤ë©´ ì´ í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•¨!
    public float GetTriangleArea(Triangle triangle)
    {
        return (Mathf.Sqrt(3) / 4) * triangle.SideLength * triangle.SideLength;
    }

    // âš ï¸ ìœ¡ê°í˜• ì¶”ê°€í•˜ë ¤ë©´ ë˜ ìˆ˜ì •!
    public float GetHexagonArea(Hexagon hexagon)
    {
        return (3 * Mathf.Sqrt(3) / 2) * hexagon.SideLength * hexagon.SideLength;
    }

    // âš ï¸ ê³„ì† ì¶”ê°€...
    // GetPentagonArea, GetOctagonArea, GetEllipseArea...
}

public class Rectangle
{
    public float Height;
    public float Width;
}

public class Circle
{
    public float Radius;
}
```

**ë¬¸ì œì  :**
- ğŸ”´ ìƒˆ ë„í˜• ì¶”ê°€í•  ë•Œë§ˆë‹¤ `UnrefactoredAreaCalculator` ìˆ˜ì • í•„ìš”
- ğŸ”´ ê¸°ì¡´ì— ì˜ ì‘ë™í•˜ë˜ ì½”ë“œë¥¼ ê±´ë“œë ¤ì•¼ í•¨ â†’ ë²„ê·¸ ìœ„í—˜!
- ğŸ”´ ë„í˜•ì´ 10ê°œ, 20ê°œë¡œ ëŠ˜ì–´ë‚˜ë©´ í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§
- ğŸ”´ íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ì´ ê³„ì† ëŠ˜ì–´ë‚¨

**ì‚¬ìš©í•˜ëŠ” ìª½ì˜ ë¬¸ì œ :**
```csharp
public class ShapeProcessor
{
    UnrefactoredAreaCalculator calculator = new UnrefactoredAreaCalculator();

    public void ProcessShape(object shape)
    {
        // âš ï¸ íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ì´ ê³„ì† ëŠ˜ì–´ë‚¨!
        if (shape is Rectangle rect)
        {
            float area = calculator.GetRectangleArea(rect);
        }
        else if (shape is Circle circle)
        {
            float area = calculator.GetCircleArea(circle);
        }
        else if (shape is Triangle triangle)
        {
            float area = calculator.GetTriangleArea(triangle);
        }
        else if (shape is Hexagon hexagon)
        {
            float area = calculator.GetHexagonArea(hexagon);
        }
        // âš ï¸ ìƒˆ ë„í˜• ì¶”ê°€í•˜ë©´ ì—¬ê¸°ë„ ìˆ˜ì •!
        // âš ï¸ ì‹¤ìˆ˜ë¡œ ë¶„ê¸°ë¥¼ ë¹ ëœ¨ë¦¬ë©´ ë²„ê·¸ ë°œìƒ!
    }
}
```

---

### âœ… After : OCP ì ìš©

#### 1ï¸âƒ£ AreaOfEffect.cs (ì¶”ìƒ í´ë˜ìŠ¤)

```csharp
/// <summary>
/// ParticleSystemê³¼ AudioClipì„ ì¬ìƒí•˜ëŠ” í´ë˜ìŠ¤.
///
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public abstract class AreaOfEffect : MonoBehaviour
{
    [Header("Particle Effect")]
    [SerializeField] ParticleSystem m_EffectParticleSystem;

    [Header("Audio Effect")]
    [SerializeField] AudioSource m_EffectAudioSource;
    [SerializeField] AudioClip   m_EffectSoundFX;

    [Space]
    [SerializeField] float  m_CooldownTime = 1.0f;
    [SerializeField] string m_LabelString;
    [SerializeField] Text   m_LabelText;

    /// <summary> ì´ AreaOfEffectì˜ íŒŒí‹°í´ ì‹œìŠ¤í…œ </summary>
    public ParticleSystem EffectParticleSystem => m_EffectParticleSystem;
    /// <summary> ì´ AreaOfEffectì˜ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ </summary>
    public AudioSource EffectAudioSource => m_EffectAudioSource;
    /// <summary> ì´ AreaOfEffectì˜ ì˜¤ë””ì˜¤ í´ë¦½ </summary>
    public AudioClip EffectSoundFX => m_EffectSoundFX;

    private float cooldownTimer;

    /// <summary>
    /// ê° AreaOfEffect ì„œë¸Œí´ë˜ìŠ¤ëŠ” ê³ ìœ í•œ CalculateArea ì •ì˜ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.
    /// </summary>
    public abstract float CalculateArea();

    /// <summary>
    /// ì‚¬ìš´ë“œì™€ íš¨ê³¼ë¥¼ ì¬ìƒí•©ë‹ˆë‹¤.
    /// </summary>
    public void PlayEffect()
    {
        // ì¿¨ë‹¤ìš´ ì‹œê°„ì´ ê²½ê³¼í–ˆëŠ”ì§€ í™•ì¸
        if (Time.time >= cooldownTimer)
        {
            cooldownTimer = Time.time + m_CooldownTime;
            PlayParticleEffect();
            PlaySoundEffect();
            ShowAreaText();  // â† ì—¬ê¸°ì„œ CalculateArea() í˜¸ì¶œ!
        }
    }

    private void PlayParticleEffect()
    {
        if (m_EffectParticleSystem != null)
        {
            m_EffectParticleSystem.Play();
        }
    }

    private void PlaySoundEffect()
    {
        if (m_EffectAudioSource != null && m_EffectSoundFX != null)
        {
            m_EffectAudioSource.PlayOneShot(m_EffectSoundFX);
        }
    }

    public void ShowAreaText()
    {
        if (m_LabelText != null)
        {
            // âœ… ì—¬ê¸°ì„œ ê° ì„œë¸Œí´ë˜ìŠ¤ì˜ CalculateArea()ê°€ í˜¸ì¶œë¨!
            // â†’ CircleEffect.CalculateArea() ë˜ëŠ”
            // â†’ RectangleEffect.CalculateArea() ë˜ëŠ”
            // â†’ HexagonEffect.CalculateArea() ë“±
            m_LabelText.text = m_LabelString + " " + CalculateArea();
        }
    }
}
```

**ì±…ì„ : ê³µí†µ ê¸°ëŠ¥ ì œê³µ**
- ì¶”ìƒ ë©”ì„œë“œ `CalculateArea()` ì •ì˜
- íŒŒí‹°í´ íš¨ê³¼ ì¬ìƒ
- ì‚¬ìš´ë“œ ì¬ìƒ
- ë©´ì  í‘œì‹œ

**ğŸ“ í˜¸ì¶œ ì²´ì¸ (Call Chain) :**
```
ì™¸ë¶€ì—ì„œ í˜¸ì¶œ : PlayEffect()
    â†“
ë‚´ë¶€ í˜¸ì¶œ : ShowAreaText()
    â†“
ì¶”ìƒ ë©”ì„œë“œ í˜¸ì¶œ : CalculateArea()  â† ê° ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„!
    â†“
ê²°ê³¼ ë°˜í™˜ : ê³„ì‚°ëœ ë©´ì  ê°’
```

---

#### 2ï¸âƒ£ CircleEffect.cs (ì›í˜• íš¨ê³¼)

```csharp
/// <summary>
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public class CircleEffect : AreaOfEffect
{
    [Header("Shape")]
    [Tooltip("ì›ì˜ ë°˜ì§€ë¦„")]
    [SerializeField] float m_Radius;

    public float Radius { get => m_Radius; set => m_Radius = value; }

    public override float CalculateArea()
    {
        return Radius * Radius * Mathf.PI;
    }
}
```

**ì±…ì„ : ì›í˜• ë©´ì  ê³„ì‚°**
- `CalculateArea()` êµ¬í˜„ (ì› ê³µì‹)

---

#### 3ï¸âƒ£ RectangleEffect.cs (ì‚¬ê°í˜• íš¨ê³¼)

```csharp
/// <summary>
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public class RectangleEffect : AreaOfEffect
{
    [Header("Shape")]
    [Tooltip("ì‚¬ê°í˜•ì˜ ë„ˆë¹„")]
    [SerializeField] private float m_Width;
    [Tooltip("ì‚¬ê°í˜•ì˜ ë†’ì´")]
    [SerializeField] private float m_Height;

    public override float CalculateArea()
    {
        return m_Width * m_Height;
    }
}
```

**ì±…ì„ : ì‚¬ê°í˜• ë©´ì  ê³„ì‚°**
- `CalculateArea()` êµ¬í˜„ (ê°€ë¡œ Ã— ì„¸ë¡œ)

---

#### 4ï¸âƒ£ HexagonalEffect.cs (ìœ¡ê°í˜• íš¨ê³¼)

```csharp
/// <summary>
/// ìœ¡ê°í˜• íš¨ê³¼ë¥¼ í‘œì‹œí•˜ëŠ” í´ë˜ìŠ¤.
///
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public class HexagonalEffect : AreaOfEffect
{
    [Header("Shape")]
    [Tooltip("ìœ¡ê°í˜•ì˜ í•œ ë³€ ê¸¸ì´")]
    [SerializeField] private float m_SideLength;

    public override float CalculateArea()
    {
        return (3 * Mathf.Sqrt(3) / 2) * m_SideLength * m_SideLength;
    }
}
```

**ì±…ì„ : ìœ¡ê°í˜• ë©´ì  ê³„ì‚°**
- `CalculateArea()` êµ¬í˜„ (ìœ¡ê°í˜• ê³µì‹)

---

#### 5ï¸âƒ£ TriangularEffect.cs (ì‚¼ê°í˜• íš¨ê³¼)

```csharp
/// <summary>
/// ì •ì‚¼ê°í˜• íš¨ê³¼ë¥¼ í‘œì‹œí•˜ëŠ” í´ë˜ìŠ¤.
///
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public class TriangularEffect : AreaOfEffect
{
    [Header("Shape")]
    [Tooltip("ì‚¼ê°í˜•ì˜ í•œ ë³€ ê¸¸ì´")]
    [SerializeField] private float m_SideLength;

    public override float CalculateArea()
    {
        return (Mathf.Sqrt(3) / 4) * m_SideLength * m_SideLength;
    }
}
```

**ì±…ì„ : ì‚¼ê°í˜• ë©´ì  ê³„ì‚°**
- `CalculateArea()` êµ¬í˜„ (ì •ì‚¼ê°í˜• ê³µì‹)

---

#### 6ï¸âƒ£ EffectTrigger.cs (ì‚¬ìš©í•˜ëŠ” ìª½)

```csharp
public class EffectTrigger : MonoBehaviour
{
    [Tooltip("ì´ ì»´í¬ë„ŒíŠ¸ì™€ ì¶©ëŒ ì‹œ íŠ¸ë¦¬ê±°ë˜ëŠ” AreaOfEffect")]
    [SerializeField] AreaOfEffect m_Effect;
    [Tooltip("íŠ¸ë¦¬ê±° ê°„ ìµœì†Œ ì‹œê°„(ì´ˆ)")]
    [SerializeField] float m_Cooldown = 2f;

    float m_LastEffectTime = -1;
    const string k_PlayerTag = "Player";

    private void OnTriggerEnter(Collider other)
    {
        PlayEffect(other);

        if (other.CompareTag(k_PlayerTag) && m_Effect != null)
            m_Effect.ShowAreaText();
    }

    private void OnTriggerStay(Collider other)
    {
        if (other.CompareTag(k_PlayerTag))
            PlayEffect(other);
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag(k_PlayerTag) && m_Effect != null)
            m_Effect.ShowLabelText(string.Empty);
    }

    private void PlayEffect(Collider other)
    {
        float nextEffectTime = m_LastEffectTime + m_Cooldown;

        // íƒœê·¸ë¡œ í™•ì¸
        if (other.CompareTag(k_PlayerTag) && Time.time > nextEffectTime)
        {
            m_LastEffectTime = Time.time;

            // âœ… ì–´ë–¤ ë„í˜•ì´ë“  ë™ì¼í•˜ê²Œ ì²˜ë¦¬!
            // âœ… ë¶„ê¸°ë¬¸ ì—†ìŒ!
            m_Effect.PlayEffect();
            // â†³ PlayEffect() ë‚´ë¶€ì—ì„œ ShowAreaText() í˜¸ì¶œ
            //   â†³ ShowAreaText() ë‚´ë¶€ì—ì„œ CalculateArea() í˜¸ì¶œ
            //     â†’ ë‹¤í˜•ì„±ìœ¼ë¡œ ê° ë„í˜•ì˜ CalculateArea()ê°€ ìë™ ì‹¤í–‰ë¨!
        }
    }
}
```

**í•µì‹¬ :**
- âœ… `AreaOfEffect` ì¶”ìƒí™”ì—ë§Œ ì˜ì¡´
- âœ… íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ ì—†ìŒ!
- âœ… ìƒˆ ë„í˜• ì¶”ê°€í•´ë„ ì´ ì½”ë“œëŠ” ìˆ˜ì • ë¶ˆí•„ìš”!

---

### ğŸ“Š ê°œì„  íš¨ê³¼

| í•­ëª© | Before (UnrefactoredAreaCalculator) | After (OCP ì ìš©) |
|------|-------------------------------------|------------------|
| **íŒŒì¼ ìˆ˜** | 1ê°œ (ê³„ì† ëŠ˜ì–´ë‚¨) | ê° ë„í˜•ë§ˆë‹¤ 1ê°œ |
| **ìƒˆ ë„í˜• ì¶”ê°€** | ğŸ”´ ê¸°ì¡´ í´ë˜ìŠ¤ ìˆ˜ì • | ğŸŸ¢ ìƒˆ íŒŒì¼ë§Œ ì¶”ê°€ |
| **ê¸°ì¡´ ì½”ë“œ ì˜í–¥** | ğŸ”´ ìˆ˜ì • í•„ìš” | ğŸŸ¢ ìˆ˜ì • ë¶ˆí•„ìš” |
| **íƒ€ì… ì²´í¬** | ğŸ”´ ë¶„ê¸°ë¬¸ ê³„ì† ì¦ê°€ | ğŸŸ¢ ë¶„ê¸°ë¬¸ ì—†ìŒ |
| **í…ŒìŠ¤íŠ¸** | ğŸ”´ ì „ì²´ í…ŒìŠ¤íŠ¸ í•„ìš” | ğŸŸ¢ ìƒˆ ë„í˜•ë§Œ í…ŒìŠ¤íŠ¸ |
| **ë²„ê·¸ ìœ„í—˜** | ğŸ”´ ë†’ìŒ | ğŸŸ¢ ë‚®ìŒ |
| **í™•ì¥ì„±** | ğŸ”´ ë§¤ìš° ë‚®ìŒ | ğŸŸ¢ ë§¤ìš° ë†’ìŒ |

---

## ğŸ¬ ì‹¤ì „ ì‹œë®¬ë ˆì´ì…˜

### ì‹œë‚˜ë¦¬ì˜¤ : "ì˜¤ê°í˜•(Pentagon)" ì¶”ê°€í•˜ê¸°

í”„ë¡œì íŠ¸ì— ìƒˆë¡œìš´ ì˜¤ê°í˜• ë„í˜•ì„ ì¶”ê°€í•´ì•¼ í•œë‹¤ê³  ê°€ì •í•´ë´…ì‹œë‹¤.

---

### âŒ ë°©ì‹ 1 : UnrefactoredAreaCalculator (OCP ìœ„ë°˜)

#### ğŸ”´ Step 1 : ì˜¤ê°í˜• í´ë˜ìŠ¤ ì¶”ê°€

```csharp
public class Pentagon
{
    public float SideLength;
}
```

#### ğŸ”´ Step 2 : UnrefactoredAreaCalculator ìˆ˜ì • âš ï¸ ê¸°ì¡´ ì½”ë“œ ë³€ê²½!

```csharp
public class UnrefactoredAreaCalculator
{
    // ê¸°ì¡´ ë©”ì„œë“œë“¤
    public float GetRectangleArea(Rectangle rectangle)
    {
        return rectangle.Width * rectangle.Height;
    }

    public float GetCircleArea(Circle circle)
    {
        return circle.Radius * circle.Radius * Mathf.PI;
    }

    public float GetTriangleArea(Triangle triangle)
    {
        return (Mathf.Sqrt(3) / 4) * triangle.SideLength * triangle.SideLength;
    }

    // âš ï¸ ìƒˆë¡œìš´ ë©”ì„œë“œ ì¶”ê°€ (ê¸°ì¡´ í´ë˜ìŠ¤ ìˆ˜ì •!)
    public float GetPentagonArea(Pentagon pentagon)
    {
        return 1.72f * pentagon.SideLength * pentagon.SideLength;
    }

    // Hexagon, Heptagon, Octagon... ê³„ì† ì¶”ê°€í•˜ë©´?
    // ì´ í´ë˜ìŠ¤ëŠ” ê³„ì† ì»¤ì§€ê³  ë³µì¡í•´ì§!
}
```

#### ğŸ”´ Step 3 : ì‚¬ìš©í•˜ëŠ” ê³³ë„ ìˆ˜ì • âš ï¸ ë˜ ìˆ˜ì •!

```csharp
public class GameManager
{
    UnrefactoredAreaCalculator calculator = new UnrefactoredAreaCalculator();

    public void ProcessShape(object shape)
    {
        // âš ï¸ íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ì´ ê³„ì† ëŠ˜ì–´ë‚¨!
        if (shape is Rectangle rect)
        {
            float area = calculator.GetRectangleArea(rect);
            Debug.Log("Rectangle Area : " + area);
        }
        else if (shape is Circle circle)
        {
            float area = calculator.GetCircleArea(circle);
            Debug.Log("Circle Area : " + area);
        }
        else if (shape is Triangle triangle)
        {
            float area = calculator.GetTriangleArea(triangle);
            Debug.Log("Triangle Area : " + area);
        }
        else if (shape is Pentagon pentagon)  // âš ï¸ ìƒˆë¡œìš´ ë¶„ê¸° ì¶”ê°€!
        {
            float area = calculator.GetPentagonArea(pentagon);
            Debug.Log("Pentagon Area : " + area);
        }
        // Hexagon, Heptagon, Octagon ì¶”ê°€í•˜ë©´ ë˜ ë¶„ê¸° ì¶”ê°€...
        // 10ê°œ, 20ê°œë¡œ ëŠ˜ì–´ë‚˜ë©´?
        // â†’ ì´ ë©”ì„œë“œëŠ” ê±°ëŒ€í•œ if-else ë©ì–´ë¦¬ê°€ ë¨!
    }
}
```

#### âš ï¸ ë¬¸ì œì  ì •ë¦¬

âŒ **íì‡„ ì›ì¹™ ìœ„ë°˜ (Closed for Modification)**
   - ìƒˆ ë„í˜• ì¶”ê°€í•  ë•Œë§ˆë‹¤ `UnrefactoredAreaCalculator` í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•¨
   - ê¸°ì¡´ì— ì˜ ì‘ë™í•˜ë˜ ì½”ë“œë¥¼ ê±´ë“œë ¤ì•¼ í•¨
   - ë²„ê·¸ ë°œìƒ ìœ„í—˜ ì¦ê°€!

âŒ **ê°œë°© ì›ì¹™ ìœ„ë°˜ (Open for Extension)**
   - í™•ì¥ì´ ì–´ë ¤ì›€ - ë©”ì„œë“œë¥¼ ê³„ì† ì¶”ê°€í•´ì•¼ í•¨
   - íƒ€ì… ì²´í¬ ë¶„ê¸°ë¬¸ì´ ê³„ì† ëŠ˜ì–´ë‚¨
   - ì‹¤ìˆ˜ë¡œ ë¶„ê¸°ë¥¼ ë¹ ëœ¨ë¦¬ë©´ ëŸ°íƒ€ì„ ë²„ê·¸!

âŒ **ìœ ì§€ë³´ìˆ˜ì„± ì €í•˜**
   - ë„í˜•ì´ 10ê°œ, 20ê°œë¡œ ëŠ˜ì–´ë‚˜ë©´ ì½”ë“œê°€ ë§¤ìš° ë³µì¡í•´ì§
   - í´ë˜ìŠ¤ê°€ 300ì¤„, 500ì¤„ë¡œ ë¹„ëŒ€í•´ì§
   - ìƒˆ ê°œë°œìê°€ ì´í•´í•˜ê¸° ì–´ë ¤ì›Œì§

âŒ **í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€**
   - `UnrefactoredAreaCalculator`ë¥¼ ìˆ˜ì •í•  ë•Œë§ˆë‹¤ ëª¨ë“  ë„í˜•ì„ ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•´ì•¼ í•¨
   - íšŒê·€ í…ŒìŠ¤íŠ¸(Regression Test) ë¶€ë‹´ ì¦ê°€
   - í…ŒìŠ¤íŠ¸ ì‹œê°„ ì¦ê°€

âŒ **í˜‘ì—… ì¶©ëŒ**
   - íŒ€ì› Aê°€ Hexagon ì¶”ê°€, íŒ€ì› Bê°€ Octagon ì¶”ê°€
   - ê°™ì€ íŒŒì¼(`UnrefactoredAreaCalculator.cs`) ìˆ˜ì • â†’ Git ì¶©ëŒ ë°œìƒ!

---

### âœ… ë°©ì‹ 2 : AreaOfEffect íŒ¨í„´ (OCP ì¤€ìˆ˜)

#### ğŸŸ¢ Step 1 : ì˜¤ê°í˜• íš¨ê³¼ í´ë˜ìŠ¤ ì¶”ê°€ (ìƒˆ íŒŒì¼) âœ… í™•ì¥!

```csharp
// ğŸ“ ìƒˆ íŒŒì¼ : PentagonEffect.cs
/// <summary>
/// ì •ì˜¤ê°í˜• íš¨ê³¼ë¥¼ í‘œì‹œí•˜ëŠ” í´ë˜ìŠ¤.
///
/// ê° íš¨ê³¼ ì˜ì—­ì€ ê³ ìœ í•œ ë©´ì  ê³„ì‚° ê³µì‹ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
/// ìƒˆë¡œìš´ AreaOfEffectë¥¼ ìƒì„±í•´ë„ ê¸°ì¡´ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©°,
/// ì´ëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open Closed Principle)ì„ ë”°ë¦…ë‹ˆë‹¤.
/// </summary>
public class PentagonEffect : AreaOfEffect
{
    [Header("Shape")]
    [Tooltip("ì˜¤ê°í˜•ì˜ í•œ ë³€ ê¸¸ì´")]
    [SerializeField] private float m_SideLength;

    public override float CalculateArea()
    {
        // ì •ì˜¤ê°í˜• ë©´ì  ê³µì‹
        return 1.72f * m_SideLength * m_SideLength;
    }
}
```

#### ğŸŸ¢ Step 2 : ê¸°ì¡´ ì½”ë“œëŠ” ì „í˜€ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ! âœ… íì‡„!

```csharp
// AreaOfEffect.cs - ìˆ˜ì • ì—†ìŒ! âœ…
public abstract class AreaOfEffect : MonoBehaviour
{
    public abstract float CalculateArea();
    public void PlayEffect() { /* ... */ }
    // ... ê¸°íƒ€ ë©”ì„œë“œë“¤
}

// CircleEffect.cs - ìˆ˜ì • ì—†ìŒ! âœ…
// RectangleEffect.cs - ìˆ˜ì • ì—†ìŒ! âœ…
// HexagonalEffect.cs - ìˆ˜ì • ì—†ìŒ! âœ…
// TriangularEffect.cs - ìˆ˜ì • ì—†ìŒ! âœ…
```

#### ğŸŸ¢ Step 3 : ì‚¬ìš©í•˜ëŠ” ê³³ë„ ìˆ˜ì • ë¶ˆí•„ìš”! âœ… íì‡„!

```csharp
// EffectTrigger.cs - ìˆ˜ì • ì—†ìŒ! âœ…
public class EffectTrigger : MonoBehaviour
{
    // âœ… ì–´ë–¤ ë„í˜•ì´ë“  AreaOfEffectë¡œ ì²˜ë¦¬!
    [SerializeField] AreaOfEffect m_Effect;

    private void PlayEffect(Collider other)
    {
        // âœ… ë¶„ê¸°ë¬¸ ì—†ìŒ! ë‹¤í˜•ì„±ìœ¼ë¡œ ìë™ ì²˜ë¦¬!
        // âœ… PentagonEffectë“  HexagonEffectë“  ë™ì¼í•˜ê²Œ ì‘ë™!
        m_Effect.PlayEffect();
        // â†³ PlayEffect() ë‚´ë¶€ì—ì„œ ShowAreaText() í˜¸ì¶œ
        //   â†³ ShowAreaText() ë‚´ë¶€ì—ì„œ CalculateArea() í˜¸ì¶œ
        //     â†’ ìë™ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ë„í˜•ì˜ CalculateArea() ì‹¤í–‰ë¨!
    }
}
```

**Unity Editorì—ì„œ :**
```
Inspectorì—ì„œ m_Effectì— PentagonEffectë¥¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­ë§Œ í•˜ë©´ ë!
ì½”ë“œ ìˆ˜ì • ì—†ìŒ!
```

#### âœ… ì¥ì  ì •ë¦¬

âœ… **ê°œë°© ì›ì¹™ ì¤€ìˆ˜ (Open for Extension)**
   - ìƒˆë¡œìš´ ë„í˜• ì¶”ê°€ëŠ” ììœ ë¡­ê²Œ ê°€ëŠ¥ (í™•ì¥ì— ê°œë°©)
   - ìƒˆ íŒŒì¼(`PentagonEffect.cs`)ë§Œ ì¶”ê°€í•˜ë©´ ë¨
   - 10ê°œ, 20ê°œ, 100ê°œ ë„í˜• ì¶”ê°€í•´ë„ ë™ì¼í•œ ë°©ì‹

âœ… **íì‡„ ì›ì¹™ ì¤€ìˆ˜ (Closed for Modification)**
   - ê¸°ì¡´ ì½”ë“œëŠ” ì „í˜€ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ (ìˆ˜ì •ì— íì‡„)
   - `AreaOfEffect`, `CircleEffect`, `EffectTrigger` ë“± ëª¨ë‘ ì•ˆì „
   - ë²„ê·¸ ë°œìƒ ìœ„í—˜ ìµœì†Œí™”

âœ… **ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ**
   - ê° ë„í˜•ì´ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬ë¨
   - ì½”ë“œê°€ ê¹”ë”í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ì›€
   - ìƒˆ íŒ€ì›ë„ ì‰½ê²Œ íŒŒì•… ê°€ëŠ¥

âœ… **í…ŒìŠ¤íŠ¸ ìš©ì´**
   - ìƒˆë¡œìš´ `PentagonEffect`ë§Œ í…ŒìŠ¤íŠ¸í•˜ë©´ ë¨
   - ê¸°ì¡´ ë„í˜•ë“¤ì€ ì˜í–¥ë°›ì§€ ì•ŠìŒ
   - íšŒê·€ í…ŒìŠ¤íŠ¸ ë¶ˆí•„ìš”

âœ… **í˜‘ì—… íš¨ìœ¨**
   - íŒ€ì›ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ íŒŒì¼ ì‘ì—…
   - Git ì¶©ëŒ ì—†ìŒ
   - ë³‘ë ¬ ê°œë°œ ê°€ëŠ¥

---

### ğŸ”¥ ê·œëª¨ë³„ ë¹„êµ ì‹œë®¬ë ˆì´ì…˜

#### ğŸ“Š ì‹œë‚˜ë¦¬ì˜¤ : 10ê°œì˜ ë„í˜•ì„ ì§€ì›í•˜ëŠ” ê²Œì„ ê°œë°œ

**âŒ UnrefactoredAreaCalculator ë°©ì‹ :**

```csharp
public class UnrefactoredAreaCalculator
{
    // 10ê°œì˜ ë©”ì„œë“œê°€ í•„ìš” (í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§)
    public float GetRectangleArea(Rectangle rectangle) { /*...*/ }
    public float GetCircleArea(Circle circle) { /*...*/ }
    public float GetTriangleArea(Triangle triangle) { /*...*/ }
    public float GetPentagonArea(Pentagon pentagon) { /*...*/ }
    public float GetHexagonArea(Hexagon hexagon) { /*...*/ }
    public float GetHeptagonArea(Heptagon heptagon) { /*...*/ }
    public float GetOctagonArea(Octagon octagon) { /*...*/ }
    public float GetEllipseArea(Ellipse ellipse) { /*...*/ }
    public float GetTrapezoidArea(Trapezoid trapezoid) { /*...*/ }
    public float GetRhombusArea(Rhombus rhombus) { /*...*/ }
}
// âš ï¸ ì•½ 300ì¤„ ì´ìƒì˜ ê±°ëŒ€í•œ í´ë˜ìŠ¤!

// ì‚¬ìš©í•˜ëŠ” ìª½
public class ShapeProcessor
{
    UnrefactoredAreaCalculator calculator = new UnrefactoredAreaCalculator();

    public void ProcessShape(object shape)
    {
        // âš ï¸ 10ê°œì˜ if-else ë¶„ê¸°!
        if (shape is Rectangle rect)
            float area = calculator.GetRectangleArea(rect);
        else if (shape is Circle circle)
            float area = calculator.GetCircleArea(circle);
        else if (shape is Triangle triangle)
            float area = calculator.GetTriangleArea(triangle);
        else if (shape is Pentagon pentagon)
            float area = calculator.GetPentagonArea(pentagon);
        else if (shape is Hexagon hexagon)
            float area = calculator.GetHexagonArea(hexagon);
        else if (shape is Heptagon heptagon)
            float area = calculator.GetHeptagonArea(heptagon);
        else if (shape is Octagon octagon)
            float area = calculator.GetOctagonArea(octagon);
        else if (shape is Ellipse ellipse)
            float area = calculator.GetEllipseArea(ellipse);
        else if (shape is Trapezoid trapezoid)
            float area = calculator.GetTrapezoidArea(trapezoid);
        else if (shape is Rhombus rhombus)
            float area = calculator.GetRhombusArea(rhombus);

        // âš ï¸ 11ë²ˆì§¸ ë„í˜• ì¶”ê°€í•˜ë©´?
        // â†’ UnrefactoredAreaCalculator ìˆ˜ì •
        // â†’ ì—¬ê¸°ë„ ë¶„ê¸° ì¶”ê°€
        // â†’ ëª¨ë“  ë„í˜• ë‹¤ì‹œ í…ŒìŠ¤íŠ¸
    }
}
// âš ï¸ ì•½ 100ì¤„ì˜ ë³µì¡í•œ ë¶„ê¸°ë¬¸!
```

**ë¬¸ì œì  :**
- ğŸ”´ `UnrefactoredAreaCalculator` í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§ (300+ ì¤„)
- ğŸ”´ if-else ë¶„ê¸°ë¬¸ì´ ë³µì¡í•´ì§ (ê°€ë…ì„± ì €í•˜)
- ğŸ”´ ìƒˆ ë„í˜• ì¶”ê°€ ì‹œ ì—¬ëŸ¬ ê³³ì„ ìˆ˜ì •í•´ì•¼ í•¨
- ğŸ”´ ì‹¤ìˆ˜ë¡œ ë¶„ê¸°ë¥¼ ë¹ ëœ¨ë¦´ ìœ„í—˜
- ğŸ”´ ì½”ë“œ ë¦¬ë·°ê°€ ì–´ë ¤ì›Œì§
- ğŸ”´ íŒ€ì›ë“¤ì´ ê°™ì€ íŒŒì¼ì„ ë™ì‹œì— ìˆ˜ì • â†’ Git ì¶©ëŒ

**âœ… AreaOfEffect íŒ¨í„´ ë°©ì‹ :**

```csharp
// 10ê°œì˜ ë…ë¦½ì ì¸ íŒŒì¼ (ê° 30-40ì¤„)
// ğŸ“ CircleEffect.cs
public class CircleEffect : AreaOfEffect
{
    [SerializeField] private float m_Radius;
    public override float CalculateArea() { return m_Radius * m_Radius * Mathf.PI; }
}

// ğŸ“ RectangleEffect.cs
public class RectangleEffect : AreaOfEffect
{
    [SerializeField] private float m_Width;
    [SerializeField] private float m_Height;
    public override float CalculateArea() { return m_Width * m_Height; }
}

// ğŸ“ TriangleEffect.cs
public class TriangleEffect : AreaOfEffect
{
    [SerializeField] private float m_SideLength;
    public override float CalculateArea() { return (Mathf.Sqrt(3) / 4) * m_SideLength * m_SideLength; }
}

// ... ë‚˜ë¨¸ì§€ 7ê°œ íŒŒì¼ë„ ë™ì¼í•œ íŒ¨í„´ (ê°ê° ë…ë¦½ì ) ...

// ì‚¬ìš©í•˜ëŠ” ìª½
public class EffectTrigger : MonoBehaviour
{
    // âœ… ë‹¨ í•œ ì¤„! ëª¨ë“  ë„í˜• ì§€ì›!
    [SerializeField] AreaOfEffect m_Effect;

    private void PlayEffect(Collider other)
    {
        // âœ… ë¶„ê¸°ë¬¸ ì—†ìŒ! ë‹¤í˜•ì„±ì´ ìë™ ì²˜ë¦¬!
        m_Effect.PlayEffect();

        // âœ… 11ë²ˆì§¸ ë„í˜• ì¶”ê°€í•´ë„ ì´ ì½”ë“œëŠ” ê·¸ëŒ€ë¡œ!
        // âœ… 20ë²ˆì§¸ ë„í˜• ì¶”ê°€í•´ë„ ì´ ì½”ë“œëŠ” ê·¸ëŒ€ë¡œ!
        // âœ… 100ë²ˆì§¸ ë„í˜• ì¶”ê°€í•´ë„ ì´ ì½”ë“œëŠ” ê·¸ëŒ€ë¡œ!
    }
}
```

**ì¥ì  :**
- ğŸŸ¢ ê° ë„í˜•ì´ ë…ë¦½ì ì¸ íŒŒì¼ (30-40ì¤„)
- ğŸŸ¢ ë¶„ê¸°ë¬¸ ì—†ìŒ (ë‹¤í˜•ì„± í™œìš©)
- ğŸŸ¢ ìƒˆ ë„í˜• ì¶”ê°€ ì‹œ ìƒˆ íŒŒì¼ë§Œ ì¶”ê°€
- ğŸŸ¢ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”
- ğŸŸ¢ ì½”ë“œ ë¦¬ë·°ê°€ ì‰¬ì›€
- ğŸŸ¢ íŒ€ì›ë“¤ì´ ë…ë¦½ì ìœ¼ë¡œ ì‘ì—… ê°€ëŠ¥

---

### ğŸ“ˆ ì½”ë“œ ê·œëª¨ì— ë”°ë¥¸ ë³µì¡ë„ ë¹„êµ

```
ë„í˜• ê°œìˆ˜    â”‚ UnrefactoredAreaCalculator â”‚ AreaOfEffect íŒ¨í„´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1ê°œ         â”‚ ê°„ë‹¨ (20ì¤„)                  â”‚ ê°„ë‹¨ (30ì¤„)
            â”‚ - í´ë˜ìŠ¤ 1ê°œ                 â”‚ - í´ë˜ìŠ¤ 2ê°œ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3ê°œ         â”‚ ë³´í†µ (80ì¤„)                  â”‚ ë³´í†µ (90ì¤„)
            â”‚ - í´ë˜ìŠ¤ 1ê°œ                 â”‚ - í´ë˜ìŠ¤ 4ê°œ
            â”‚ - ë©”ì„œë“œ 3ê°œ                 â”‚ - íŒŒì¼ 4ê°œ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5ê°œ         â”‚ ë³µì¡ (150ì¤„)                 â”‚ ê°„ë‹¨ (150ì¤„, 6íŒŒì¼)
            â”‚ - í´ë˜ìŠ¤ 1ê°œ (ë¹„ëŒ€)          â”‚ - ê° í´ë˜ìŠ¤ 25ì¤„
            â”‚ - ë©”ì„œë“œ 5ê°œ                 â”‚ - ë…ë¦½ì  ê´€ë¦¬
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10ê°œ        â”‚ ë§¤ìš° ë³µì¡ (350ì¤„)            â”‚ ë³´í†µ (300ì¤„, 11íŒŒì¼)
            â”‚ - í´ë˜ìŠ¤ 1ê°œ (ê±°ëŒ€)          â”‚ - ê° í´ë˜ìŠ¤ 27ì¤„
            â”‚ - ë©”ì„œë“œ 10ê°œ                â”‚ - ì—¬ì „íˆ ëª…í™•
            â”‚ - ë¶„ê¸°ë¬¸ 10ê°œ                â”‚ - ë¶„ê¸°ë¬¸ 0ê°œ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
20ê°œ        â”‚ ê±°ì˜ ë¶ˆê°€ëŠ¥ (800ì¤„)          â”‚ ê´€ë¦¬ ê°€ëŠ¥ (600ì¤„, 21íŒŒì¼)
            â”‚ - í´ë˜ìŠ¤ 1ê°œ (ê´´ë¬¼)          â”‚ - ê° í´ë˜ìŠ¤ 28ì¤„
            â”‚ - ë©”ì„œë“œ 20ê°œ                â”‚ - êµ¬ì¡° ì¼ê´€ì„± ìœ ì§€
            â”‚ - ë¶„ê¸°ë¬¸ 20ê°œ                â”‚ - ë¶„ê¸°ë¬¸ 0ê°œ
            â”‚ - ìœ ì§€ë³´ìˆ˜ ë¶ˆê°€              â”‚ - ì—¬ì „íˆ ì‰¬ì›€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
50ê°œ        â”‚ ì™„ì „íˆ ë¶ˆê°€ëŠ¥                â”‚ ì—¬ì „íˆ ê´€ë¦¬ ê°€ëŠ¥
            â”‚ - 2000ì¤„ ì´ìƒ                â”‚ - 1500ì¤„, 51íŒŒì¼
            â”‚ - ì½ì„ ìˆ˜ ì—†ëŠ” ì½”ë“œ          â”‚ - ê° í´ë˜ìŠ¤ 29ì¤„
            â”‚ - ë²„ê·¸ ì˜¨ìƒ                  â”‚ - êµ¬ì¡° ì¼ê´€ì„± ìœ ì§€
```

**í•µì‹¬ :**
- ğŸ”´ ë„í˜•ì´ ëŠ˜ì–´ë‚ ìˆ˜ë¡ UnrefactoredAreaCalculatorëŠ” **ì§€ìˆ˜ì ìœ¼ë¡œ** ë³µì¡í•´ì§
- ğŸŸ¢ AreaOfEffect íŒ¨í„´ì€ **ì„ í˜•ì ìœ¼ë¡œë§Œ** ì¦ê°€í•¨
- ğŸŸ¢ ë„í˜•ì´ 100ê°œê°€ ë˜ì–´ë„ ê° í´ë˜ìŠ¤ëŠ” ì—¬ì „íˆ 30ì¤„ ë‚´ì™¸!

---

### ğŸ”¥ í•µì‹¬ ë¹„ìœ  : ë ˆìŠ¤í† ë‘ ì£¼ë°©

**âŒ UnrefactoredAreaCalculator = ë§ŒëŠ¥ ì…°í”„ í•œ ëª…**

```
                 ë§ŒëŠ¥ ì…°í”„ (UnrefactoredAreaCalculator)
                          |
    +---------+-----------+-----------+---------+---------+
    |         |           |           |         |         |
  í”¼ì     ìŠ¤íŒŒê²Œí‹°    ìŠ¤í…Œì´í¬    ìƒëŸ¬ë“œ   ë””ì €íŠ¸   ìŒë£Œ

ê³ ê° : "í”¼ì ì£¼ì„¸ìš”"
ì…°í”„ : (if í”¼ìë©´) { í”¼ì ë§Œë“œëŠ” ë°©ë²•... }

ê³ ê° : "ìŠ¤íŒŒê²Œí‹° ì£¼ì„¸ìš”"
ì…°í”„ : (else if ìŠ¤íŒŒê²Œí‹°ë©´) { ìŠ¤íŒŒê²Œí‹° ë§Œë“œëŠ” ë°©ë²•... }

ê³ ê° : "ìŠ¤í…Œì´í¬ ì£¼ì„¸ìš”"
ì…°í”„ : (else if ìŠ¤í…Œì´í¬ë©´) { ìŠ¤í…Œì´í¬ ë§Œë“œëŠ” ë°©ë²•... }

âš ï¸ ìƒˆ ë©”ë‰´(ë¼ìëƒ) ì¶”ê°€í•˜ë ¤ë©´?
- ì…°í”„ì˜ ë ˆì‹œí”¼ë¶(UnrefactoredAreaCalculator í´ë˜ìŠ¤)ì„ ìˆ˜ì •í•´ì•¼ í•¨
- ì…°í”„ê°€ ëª¨ë“  ìš”ë¦¬ë²•ì„ ì•Œì•„ì•¼ í•¨ (í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§)
- ì…°í”„ê°€ ì‹¤ìˆ˜í•˜ë©´ ëª¨ë“  ìš”ë¦¬ê°€ ì˜í–¥ë°›ìŒ (ë²„ê·¸ ìœ„í—˜)
- ìƒˆ ìš”ë¦¬ ì¶”ê°€í•  ë•Œë§ˆë‹¤ ê¸°ì¡´ ë ˆì‹œí”¼ë¶ ìˆ˜ì • (ìˆ˜ì •ì— ê°œë°©)
- ë ˆì‹œí”¼ë¶ì´ 100í˜ì´ì§€, 200í˜ì´ì§€ë¡œ ëŠ˜ì–´ë‚¨ (ìœ ì§€ë³´ìˆ˜ ë¶ˆê°€)
```

**âœ… AreaOfEffect íŒ¨í„´ = ì „ë¬¸ ì…°í”„ ì—¬ëŸ¬ ëª…**

```
              ì£¼ë°©ì¥ (AreaOfEffect ì¶”ìƒ í´ë˜ìŠ¤)
                  "ìš”ë¦¬ ë‹´ë‹¹ìë¥¼ ë°°ì •í•©ë‹ˆë‹¤"
                          |
    +---------+-----------+-----------+---------+---------+
    |         |           |           |         |         |
  í”¼ì      ìŠ¤íŒŒê²Œí‹°    ìŠ¤í…Œì´í¬    ìƒëŸ¬ë“œ   ë””ì €íŠ¸
  ì…°í”„      ì…°í”„        ì…°í”„        ì…°í”„     ì…°í”„
  (Circle)  (Rectangle) (Triangle)  (Hexagon) (Pentagon)

ê³ ê° : "í”¼ì ì£¼ì„¸ìš”"
ì£¼ë°©ì¥ : "í”¼ì ì…°í”„ë‹˜, ìš”ë¦¬í•´ ì£¼ì„¸ìš”" â† ìœ„ì„!
í”¼ì ì…°í”„ : "ë„¤!" â†’ í”¼ì ì „ë¬¸ ì¡°ë¦¬

ê³ ê° : "ìŠ¤íŒŒê²Œí‹° ì£¼ì„¸ìš”"
ì£¼ë°©ì¥ : "ìŠ¤íŒŒê²Œí‹° ì…°í”„ë‹˜, ìš”ë¦¬í•´ ì£¼ì„¸ìš”" â† ìœ„ì„!
ìŠ¤íŒŒê²Œí‹° ì…°í”„ : "ë„¤!" â†’ ìŠ¤íŒŒê²Œí‹° ì „ë¬¸ ì¡°ë¦¬

âœ… ìƒˆ ë©”ë‰´(ë¼ìëƒ) ì¶”ê°€í•˜ë ¤ë©´?
- ìƒˆë¡œìš´ ë¼ìëƒ ì „ë¬¸ ì…°í”„ë§Œ ê³ ìš©í•˜ë©´ ë¨ (ìƒˆ í´ë˜ìŠ¤ ì¶”ê°€)
- ê¸°ì¡´ ì…°í”„ë“¤ì€ ì˜í–¥ë°›ì§€ ì•ŠìŒ (ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ìŒ)
- ê° ì…°í”„ëŠ” ìê¸° ìš”ë¦¬ë§Œ ì˜í•˜ë©´ ë¨ (ë‹¨ì¼ ì±…ì„)
- ì£¼ë°©ì¥ì€ "ìš”ë¦¬í•´ ì£¼ì„¸ìš”"ë§Œ ë§í•˜ë©´ ë¨ (ë‹¤í˜•ì„±)
- 100ëª…ì˜ ì…°í”„ê°€ ìˆì–´ë„ ì£¼ë°©ì¥ ì—…ë¬´ëŠ” ë™ì¼ (í™•ì¥ì„±)
```

---

## ğŸ’» ì£¼ìš” ì½”ë“œ ë¶„ì„

### ğŸ“Œ í•µì‹¬ 1 : ì¶”ìƒ ë©”ì„œë“œ ì •ì˜

**AreaOfEffect.cs :**
```csharp
public abstract class AreaOfEffect : MonoBehaviour
{
    /// <summary>
    /// ê° AreaOfEffect ì„œë¸Œí´ë˜ìŠ¤ëŠ” ê³ ìœ í•œ CalculateArea ì •ì˜ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.
    /// </summary>
    public abstract float CalculateArea();  // â† ì¶”ìƒ ë©”ì„œë“œ!

    public void PlayEffect()
    {
        // ...
        ShowAreaText();  // â† ë‚´ë¶€ì—ì„œ í˜¸ì¶œ
        // ...
    }

    public void ShowAreaText()
    {
        // ...
        float area = CalculateArea();  // â† ë‹¤í˜•ì„±ìœ¼ë¡œ ìë™ í˜¸ì¶œ!
        // ...
    }
}
```

**íš¨ê³¼ :**
- âœ… ëª¨ë“  ì„œë¸Œí´ë˜ìŠ¤ê°€ `CalculateArea()`ë¥¼ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•¨
- âœ… ì»´íŒŒì¼ íƒ€ì„ì— ê°•ì œ (ì‹¤ìˆ˜ ë°©ì§€)
- âœ… ì¸í„°í˜ì´ìŠ¤ ì¼ê´€ì„± ë³´ì¥

**ğŸ“ í˜¸ì¶œ íë¦„ :**
```
EffectTrigger.PlayEffect(other)
    â†“
m_Effect.PlayEffect()  â† AreaOfEffectì˜ ë©”ì„œë“œ
    â†“
ShowAreaText()  â† AreaOfEffectì˜ ë©”ì„œë“œ
    â†“
CalculateArea()  â† ì¶”ìƒ ë©”ì„œë“œ! ê° ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„ë¨
    â†“
ì‹¤ì œ êµ¬í˜„ ë©”ì„œë“œ ì‹¤í–‰ :
- CircleEffect.CalculateArea() ë˜ëŠ”
- RectangleEffect.CalculateArea() ë˜ëŠ”
- HexagonEffect.CalculateArea() ë“±
```

---

### ğŸ“Œ í•µì‹¬ 2 : ë‹¤í˜•ì„± í™œìš©

**ì‚¬ìš©í•˜ëŠ” ìª½ (EffectTrigger.cs) :**
```csharp
public class EffectTrigger : MonoBehaviour
{
    // âœ… ì¶”ìƒ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸!
    [SerializeField] AreaOfEffect m_Effect;

    private void PlayEffect(Collider other)
    {
        // âœ… ëŸ°íƒ€ì„ì— ì‹¤ì œ íƒ€ì… ê²°ì •!
        m_Effect.PlayEffect();
        // â†³ PlayEffect() ë‚´ë¶€ì—ì„œ ShowAreaText() í˜¸ì¶œ
        //   â†³ ShowAreaText() ë‚´ë¶€ì—ì„œ CalculateArea() í˜¸ì¶œ
        //     â†’ m_Effectê°€ CircleEffectë©´ â†’ CircleEffect.CalculateArea()
        //     â†’ m_Effectê°€ RectangleEffectë©´ â†’ RectangleEffect.CalculateArea()
        //     â†’ m_Effectê°€ HexagonEffectë©´ â†’ HexagonEffect.CalculateArea()
    }
}
```

**ë‹¤í˜•ì„±ì˜ ë§ˆë²• :**
```csharp
// Unity Inspectorì—ì„œ í• ë‹¹
EffectTrigger.m_Effect = CircleEffect ì¸ìŠ¤í„´ìŠ¤
â†’ m_Effect.PlayEffect() í˜¸ì¶œ ì‹œ
  â†³ PlayEffect() â†’ ShowAreaText() â†’ CalculateArea()
    â†’ CircleEffect.CalculateArea() ìë™ í˜¸ì¶œ!

EffectTrigger.m_Effect = HexagonEffect ì¸ìŠ¤í„´ìŠ¤
â†’ m_Effect.PlayEffect() í˜¸ì¶œ ì‹œ
  â†³ PlayEffect() â†’ ShowAreaText() â†’ CalculateArea()
    â†’ HexagonEffect.CalculateArea() ìë™ í˜¸ì¶œ!

// âœ… ì½”ë“œ ìˆ˜ì • ì—†ì´ ë™ì‘ ë³€ê²½!
// âœ… ëŸ°íƒ€ì„ì— ë™ì ìœ¼ë¡œ ê²°ì •!
// âœ… PlayEffect() â†’ ShowAreaText() â†’ CalculateArea() í˜¸ì¶œ ì²´ì¸!
```

---

### ğŸ“Œ í•µì‹¬ 3 : í™•ì¥ì˜ ìš©ì´ì„±

**ìƒˆ ë„í˜• ì¶”ê°€ í”„ë¡œì„¸ìŠ¤ :**

```csharp
// 1ë‹¨ê³„ : ìƒˆ íŒŒì¼ ìƒì„± (DiamondEffect.cs)
// âœ… ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ìŒ!
public class DiamondEffect : AreaOfEffect
{
    [SerializeField] private float m_Diagonal1;
    [SerializeField] private float m_Diagonal2;

    public override float CalculateArea()
    {
        return (m_Diagonal1 * m_Diagonal2) / 2f;
    }
}

// 2ë‹¨ê³„ : ë!
// âœ… AreaOfEffect.cs ìˆ˜ì • ì•ˆ í•¨
// âœ… CircleEffect.cs ìˆ˜ì • ì•ˆ í•¨
// âœ… EffectTrigger.cs ìˆ˜ì • ì•ˆ í•¨
// âœ… Unity Inspectorì—ì„œ DiamondEffect í• ë‹¹ë§Œ í•˜ë©´ ì‘ë™!
```

**ì¶”ê°€ ì‘ì—… :**
- ì½”ë“œ ìˆ˜ì • : 0ê³³
- ìƒˆ íŒŒì¼ ìƒì„± : 1ê°œ
- í…ŒìŠ¤íŠ¸ : DiamondEffectë§Œ
- ë°°í¬ : ì•ˆì „ (ê¸°ì¡´ ì½”ë“œ ì˜í–¥ ì—†ìŒ)

---

### ğŸ“Œ í•µì‹¬ 4 : ì¶”ìƒí™”ì— ì˜ì¡´

**ì˜ì¡´ì„± ë°©í–¥ :**

```
Before (ë‚˜ìœ ì„¤ê³„) :

GameManager
    |
    â”œâ”€ depends on â†’ Rectangle (êµ¬ì²´ í´ë˜ìŠ¤)
    â”œâ”€ depends on â†’ Circle (êµ¬ì²´ í´ë˜ìŠ¤)
    â”œâ”€ depends on â†’ Triangle (êµ¬ì²´ í´ë˜ìŠ¤)
    â””â”€ depends on â†’ Hexagon (êµ¬ì²´ í´ë˜ìŠ¤)

âš ï¸ êµ¬ì²´ í´ë˜ìŠ¤ê°€ ì¶”ê°€ë  ë•Œë§ˆë‹¤ GameManager ìˆ˜ì • í•„ìš”!


After (ì¢‹ì€ ì„¤ê³„) :

EffectTrigger
    |
    â””â”€ depends on â†’ AreaOfEffect (ì¶”ìƒ í´ë˜ìŠ¤)
                         |
         +---------------+---------------+---------------+
         |               |               |               |
    CircleEffect   RectangleEffect  HexagonEffect  TriangleEffect
    (êµ¬ì²´ í´ë˜ìŠ¤)   (êµ¬ì²´ í´ë˜ìŠ¤)    (êµ¬ì²´ í´ë˜ìŠ¤)   (êµ¬ì²´ í´ë˜ìŠ¤)

âœ… EffectTriggerëŠ” ì¶”ìƒí™”(AreaOfEffect)ì—ë§Œ ì˜ì¡´!
âœ… êµ¬ì²´ í´ë˜ìŠ¤ê°€ ì¶”ê°€ë˜ì–´ë„ EffectTriggerëŠ” ìˆ˜ì • ë¶ˆí•„ìš”!
```

**DIP(Dependency Inversion Principle)ì™€ì˜ ì—°ê´€ì„± :**
- ê³ ìˆ˜ì¤€ ëª¨ë“ˆ(`EffectTrigger`)ì´ ì €ìˆ˜ì¤€ ëª¨ë“ˆ(`CircleEffect`)ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ
- ë‘˜ ë‹¤ ì¶”ìƒí™”(`AreaOfEffect`)ì— ì˜ì¡´
- ì´ê²ƒì´ SOLIDì˜ D(DIP)ì™€ ì—°ê²°ë¨!

---

## âš–ï¸ ì¥ë‹¨ì 

### âœ… ì¥ì 

**1. í™•ì¥ ìš©ì´ (Open for Extension)**
- ìƒˆë¡œìš´ ë„í˜•ì„ ììœ ë¡­ê²Œ ì¶”ê°€ ê°€ëŠ¥
- ìƒˆ íŒŒì¼ë§Œ ìƒì„±í•˜ë©´ ë¨
- ë¬´í•œ í™•ì¥ ê°€ëŠ¥

**2. ê¸°ì¡´ ì½”ë“œ ë³´í˜¸ (Closed for Modification)**
- ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ
- ë²„ê·¸ ë°œìƒ ìœ„í—˜ ìµœì†Œí™”
- ì•ˆì •ì„± ë³´ì¥

**3. ìœ ì§€ë³´ìˆ˜ ìš©ì´**
- ê° ë„í˜•ì´ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬
- ì½”ë“œ ìœ„ì¹˜ê°€ ëª…í™•
- ìˆ˜ì • ì˜í–¥ ë²”ìœ„ê°€ í•œì •ì 

**4. í…ŒìŠ¤íŠ¸ ìš©ì´**
- ìƒˆ ë„í˜•ë§Œ í…ŒìŠ¤íŠ¸í•˜ë©´ ë¨
- íšŒê·€ í…ŒìŠ¤íŠ¸ ë¶ˆí•„ìš”
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ì‰¬ì›€

**5. í˜‘ì—… íš¨ìœ¨ í–¥ìƒ**
- íŒ€ì›ë“¤ì´ ë…ë¦½ì ìœ¼ë¡œ ì‘ì—…
- Git ì¶©ëŒ ìµœì†Œí™”
- ë³‘ë ¬ ê°œë°œ ê°€ëŠ¥

**6. ì½”ë“œ ê°€ë…ì„± í–¥ìƒ**
- ê° í´ë˜ìŠ¤ê°€ ì§§ê³  ëª…í™•
- ë¶„ê¸°ë¬¸ ì—†ìŒ
- ì´í•´í•˜ê¸° ì‰¬ì›€

**7. ë‹¤í˜•ì„± í™œìš©**
- ëŸ°íƒ€ì„ì— ë™ì‘ ê²°ì •
- ìœ ì—°í•œ ì„¤ê³„
- ì½”ë“œ ì¬ì‚¬ìš©ì„± ì¦ê°€

### âŒ ë‹¨ì 

**1. ì´ˆê¸° ì„¤ê³„ ë³µì¡ë„**
- ì¶”ìƒí™” ì„¤ê³„ í•„ìš”
- ì´ˆê¸° íŒŒì¼ ìˆ˜ ì¦ê°€
- í•™ìŠµ ê³¡ì„  ì¡´ì¬

**2. ê°„ë‹¨í•œ ê¸°ëŠ¥ì—ëŠ” ê³¼ë„í•¨**
- ë„í˜•ì´ 1~2ê°œë§Œ ìˆì„ ë•ŒëŠ” ì˜¤ë²„ì—”ì§€ë‹ˆì–´ë§
- ì´ˆê¸° ê°œë°œ ì‹œê°„ ì¦ê°€

**3. ê°„ì ‘ ì°¸ì¡° ì˜¤ë²„í—¤ë“œ**
- ì¶”ìƒ ë©”ì„œë“œ í˜¸ì¶œ (ê°€ìƒ í•¨ìˆ˜)
- ì•½ê°„ì˜ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ (ë¯¸ë¯¸í•¨)

**4. ë””ë²„ê¹… ë³µì¡ë„**
- ëŸ°íƒ€ì„ì— ì‹¤ì œ íƒ€ì… í™•ì¸ í•„ìš”
- í˜¸ì¶œ ìŠ¤íƒì´ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆìŒ

---

## ğŸ® ì‹¤ì œ ì ìš© ì‚¬ë¡€

### 1ï¸âƒ£ ê²Œì„ ê°œë°œ

**ë¬´ê¸° ì‹œìŠ¤í…œ**
```csharp
// âœ… OCP ì ìš©
public abstract class Weapon
{
    public abstract void Attack();
    public abstract float GetDamage();
}

public class Sword : Weapon
{
    public override void Attack() { /* ê·¼ì ‘ ê³µê²© */ }
    public override float GetDamage() { return 10f; }
}

public class Bow : Weapon
{
    public override void Attack() { /* ì›ê±°ë¦¬ ê³µê²© */ }
    public override float GetDamage() { return 8f; }
}

public class MagicStaff : Weapon  // âœ… ìƒˆ ë¬´ê¸° ì¶”ê°€ (ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ìŒ!)
{
    public override void Attack() { /* ë§ˆë²• ê³µê²© */ }
    public override float GetDamage() { return 15f; }
}

public class Player
{
    private Weapon currentWeapon;  // âœ… ì¶”ìƒí™”ì— ì˜ì¡´

    public void Attack()
    {
        currentWeapon.Attack();  // âœ… ë‹¤í˜•ì„±ìœ¼ë¡œ ìë™ ì²˜ë¦¬
    }
}
```

**ì  AI ì‹œìŠ¤í…œ**
```csharp
// âœ… OCP ì ìš©
public abstract class EnemyAI
{
    public abstract void DecideAction();
}

public class AggressiveAI : EnemyAI
{
    public override void DecideAction() { /* ê³µê²©ì  í–‰ë™ */ }
}

public class DefensiveAI : EnemyAI
{
    public override void DecideAction() { /* ë°©ì–´ì  í–‰ë™ */ }
}

public class SneakyAI : EnemyAI  // âœ… ìƒˆ AI ì¶”ê°€
{
    public override void DecideAction() { /* ì€ë°€í•œ í–‰ë™ */ }
}
```

### 2ï¸âƒ£ UI ì‹œìŠ¤í…œ

```csharp
// âœ… OCP ì ìš©
public abstract class UIPanel
{
    public abstract void Show();
    public abstract void Hide();
}

public class InventoryPanel : UIPanel
{
    public override void Show() { /* ì¸ë²¤í† ë¦¬ í‘œì‹œ */ }
    public override void Hide() { /* ì¸ë²¤í† ë¦¬ ìˆ¨ê¹€ */ }
}

public class SkillTreePanel : UIPanel
{
    public override void Show() { /* ìŠ¤í‚¬ íŠ¸ë¦¬ í‘œì‹œ */ }
    public override void Hide() { /* ìŠ¤í‚¬ íŠ¸ë¦¬ ìˆ¨ê¹€ */ }
}

public class UIManager
{
    private UIPanel currentPanel;  // âœ… ì¶”ìƒí™”ì— ì˜ì¡´

    public void OpenPanel(UIPanel panel)
    {
        currentPanel?.Hide();
        currentPanel = panel;
        currentPanel.Show();  // âœ… ì–´ë–¤ íŒ¨ë„ì´ë“  ì‘ë™
    }
}
```

### 3ï¸âƒ£ ì €ì¥ ì‹œìŠ¤í…œ

```csharp
// âœ… OCP ì ìš©
public abstract class SaveSystem
{
    public abstract void Save(GameData data);
    public abstract GameData Load();
}

public class LocalSaveSystem : SaveSystem
{
    public override void Save(GameData data) { /* ë¡œì»¬ ì €ì¥ */ }
    public override GameData Load() { /* ë¡œì»¬ ë¡œë“œ */ }
}

public class CloudSaveSystem : SaveSystem
{
    public override void Save(GameData data) { /* í´ë¼ìš°ë“œ ì €ì¥ */ }
    public override GameData Load() { /* í´ë¼ìš°ë“œ ë¡œë“œ */ }
}

public class PlayerPrefsSaveSystem : SaveSystem  // âœ… ìƒˆ ì €ì¥ ë°©ì‹ ì¶”ê°€
{
    public override void Save(GameData data) { /* PlayerPrefs ì €ì¥ */ }
    public override GameData Load() { /* PlayerPrefs ë¡œë“œ */ }
}

public class GameManager
{
    private SaveSystem saveSystem;  // âœ… ì¶”ìƒí™”ì— ì˜ì¡´

    public void SaveGame(GameData data)
    {
        saveSystem.Save(data);  // âœ… ì–´ë–¤ ì €ì¥ ë°©ì‹ì´ë“  ì‘ë™
    }
}
```

---

## ğŸ“ í•™ìŠµ ì •ë¦¬

### í•µì‹¬ ìš”ì•½

1. **ê°œë°©-íì‡„ ì›ì¹™ (OCP)**
   - í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³  (Open for Extension)
   - ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤ (Closed for Modification)

2. **í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜**
   - ì¶”ìƒí™”(ì¶”ìƒ í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤)ë¡œ ê³µí†µ ë™ì‘ ì •ì˜
   - êµ¬ì²´ í´ë˜ìŠ¤ë“¤ì´ ì´ë¥¼ ìƒì†/êµ¬í˜„
   - ìƒˆ ê¸°ëŠ¥ì€ ìƒˆ êµ¬ì²´ í´ë˜ìŠ¤ë¡œ ì¶”ê°€
   - ê¸°ì¡´ ì½”ë“œëŠ” ì¶”ìƒí™”ì—ë§Œ ì˜ì¡´

3. **ì‹¤ì „ ì ìš© ë°©ë²•**
   - ë³€ê²½ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ë¶€ë¶„ì„ ì¶”ìƒí™”
   - ë‹¤í˜•ì„±ì„ í™œìš©í•œ ì„¤ê³„
   - ì˜ì¡´ì„±ì„ ì¶”ìƒí™”ë¡œ í–¥í•˜ê²Œ í•¨

4. **ì¥ì **
   - í™•ì¥ ìš©ì´, ê¸°ì¡´ ì½”ë“œ ë³´í˜¸, ìœ ì§€ë³´ìˆ˜ì„±, í…ŒìŠ¤íŠ¸ ìš©ì´ì„±
   - í˜‘ì—… íš¨ìœ¨, ê°€ë…ì„± í–¥ìƒ

5. **ì£¼ì˜ì‚¬í•­**
   - ê³¼ë„í•œ ì¶”ìƒí™”ëŠ” ì˜¤ë²„ì—”ì§€ë‹ˆì–´ë§
   - ë³€ê²½ ê°€ëŠ¥ì„±ì´ ë‚®ì€ ë¶€ë¶„ê¹Œì§€ ì¶”ìƒí™”í•  í•„ìš” ì—†ìŒ

### Before vs After

| í•­ëª© | Before (UnrefactoredAreaCalculator) | After (AreaOfEffect íŒ¨í„´) |
|------|-------------------------------------|---------------------------|
| **êµ¬ì¡°** | 1ê°œ ê±°ëŒ€ í´ë˜ìŠ¤ | ì¶”ìƒ í´ë˜ìŠ¤ + êµ¬ì²´ í´ë˜ìŠ¤ë“¤ |
| **í™•ì¥** | ê¸°ì¡´ í´ë˜ìŠ¤ ìˆ˜ì • | ìƒˆ í´ë˜ìŠ¤ ì¶”ê°€ |
| **ìˆ˜ì •** | ê¸°ì¡´ ì½”ë“œ ë³€ê²½ | ê¸°ì¡´ ì½”ë“œ ë³´í˜¸ |
| **ë¶„ê¸°ë¬¸** | íƒ€ì… ì²´í¬ ë¶„ê¸° ì¦ê°€ | ë¶„ê¸°ë¬¸ ì—†ìŒ (ë‹¤í˜•ì„±) |
| **í…ŒìŠ¤íŠ¸** | ì „ì²´ í…ŒìŠ¤íŠ¸ | ìƒˆ í´ë˜ìŠ¤ë§Œ í…ŒìŠ¤íŠ¸ |
| **ë²„ê·¸ ìœ„í—˜** | ë†’ìŒ | ë‚®ìŒ |
| **í™•ì¥ì„±** | ë§¤ìš° ë‚®ìŒ | ë§¤ìš° ë†’ìŒ |
| **í˜‘ì—…** | ì¶©ëŒ ìœ„í—˜ | ë…ë¦½ ì‘ì—… ê°€ëŠ¥ |

### ì‹¤ë¬´ ì ìš© íŒ

âœ… **ì´ëŸ° ê²½ìš° OCP ì ìš© ê³ ë ¤**
- ìƒˆë¡œìš´ íƒ€ì…ì´ ê³„ì† ì¶”ê°€ë  ê°€ëŠ¥ì„±ì´ ìˆì„ ë•Œ
- if-else ë˜ëŠ” switch-case ë¶„ê¸°ê°€ ë§ì„ ë•Œ
- íƒ€ì… ì²´í¬ ì½”ë“œê°€ ì—¬ëŸ¬ ê³³ì— í©ì–´ì ¸ ìˆì„ ë•Œ
- íŒ€ì›ë“¤ì´ ë™ì‹œì— ìƒˆ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ë•Œ

âŒ **ì´ëŸ° ê²½ìš° ë¬´ë¦¬í•˜ê²Œ ì ìš© X**
- ë³€ê²½ ê°€ëŠ¥ì„±ì´ ê±°ì˜ ì—†ì„ ë•Œ
- íƒ€ì…ì´ 1~2ê°œë¡œ ê³ ì •ë˜ì–´ ìˆì„ ë•Œ
- í”„ë¡œí† íƒ€ì… ë‹¨ê³„
- ê°„ë‹¨í•œ ì¼íšŒì„± ì½”ë“œ

### OCPì™€ ë‹¤ë¥¸ ì›ì¹™ì˜ ê´€ê³„

**SRP (Single Responsibility Principle)ì™€ì˜ ê´€ê³„ :**
- OCPë¥¼ ì§€í‚¤ë©´ ìì—°ìŠ¤ëŸ½ê²Œ SRPë„ ì§€ì¼œì§
- ê° êµ¬ì²´ í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§

**LSP (Liskov Substitution Principle)ì™€ì˜ ê´€ê³„ :**
- OCPë¥¼ ìœ„í•´ì„œëŠ” LSPê°€ í•„ìˆ˜
- ì„œë¸Œí´ë˜ìŠ¤ê°€ ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ì™„ë²½íˆ ëŒ€ì²´í•  ìˆ˜ ìˆì–´ì•¼ í•¨

**DIP (Dependency Inversion Principle)ì™€ì˜ ê´€ê³„ :**
- OCP êµ¬í˜„ì˜ í•µì‹¬ì€ DIP
- ì¶”ìƒí™”ì— ì˜ì¡´í•¨ìœ¼ë¡œì¨ OCP ë‹¬ì„±

### í•µì‹¬ ë¬¸êµ¬

```
"í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆë‹¤"

í™•ì¥ (Extension) : ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ììœ ë¡­ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤
ìˆ˜ì • (Modification) : ê¸°ì¡´ ì½”ë“œë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤

â†’ ìƒˆ íŒŒì¼ ì¶”ê°€ OK, ê¸°ì¡´ íŒŒì¼ ìˆ˜ì • NO!
```

### ë§ˆë¬´ë¦¬

**ê°œë°©-íì‡„ ì›ì¹™ì˜ ì§„ì •í•œ ê°€ì¹˜ :**

ì²˜ìŒ 3ê°œ ë„í˜•ë§Œ ë§Œë“¤ ë•ŒëŠ” `UnrefactoredAreaCalculator`ê°€ ë” ê°„ë‹¨í•´ ë³´ì…ë‹ˆë‹¤.

í•˜ì§€ë§Œ í”„ë¡œì íŠ¸ê°€ ì„±ì¥í•˜ë©´ì„œ 10ê°œ, 20ê°œ, 50ê°œë¡œ ëŠ˜ì–´ë‚  ë•Œ,
`AreaOfEffect` íŒ¨í„´ì˜ ì§„ê°€ê°€ ë“œëŸ¬ë‚©ë‹ˆë‹¤.

**ë‹¨ê¸°ì ìœ¼ë¡œëŠ”** ì½”ë“œê°€ ì¡°ê¸ˆ ë” ë³µì¡í•´ ë³´ì¼ ìˆ˜ ìˆì§€ë§Œ,
**ì¥ê¸°ì ìœ¼ë¡œëŠ”** ìœ ì§€ë³´ìˆ˜ì™€ í™•ì¥ì„ **ê·¹ì ìœ¼ë¡œ** ì‰½ê²Œ ë§Œë“­ë‹ˆë‹¤!

ì´ê²ƒì´ ë°”ë¡œ **ê°œë°©-íì‡„ ì›ì¹™**ì˜ í˜ì…ë‹ˆë‹¤! ğŸš€
